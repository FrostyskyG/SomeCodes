# JS Brainfuck

@(随笔)[Javascript|Brainfuck|XSS|Markdown]

### Preface
今天无意中在Alloyteam上看到一篇文章，大感兴趣，请原谅我的愚昧无知，到现在才知道js还可以这样玩。
原文是对一道XSS题的解析过程，本文则来谈谈js的brainfuck化之路。
先看看那道题目：
```js
(function escape(input) {
    input = input.replace(/[;\\\/<>a-zA-Z]/g, "_").slice(0,1500);
    return "<script>[][([![]]+[])[++[++[++[[]][+[]]][+[]]][+[]]]+([]+{})[++[[]][+[]]]+([!![]]+[])[++[[]][+[]]]+([!![]]+[])[+[]]]"+input+"</script> ";
})('?')
```
是不是被这一长串字符给看晕了，好吧，这简直就不是人看的！
```js
[][([![]]+[])[++[++[++[[]][+[]]][+[]]][+[]]]+([]+{})[++[[]][+[]]]+([!![]]+[])[++[[]][+[]]]+([!![]]+[])[+[]]]
```
放心，看完本文，保证你也会流利的手写一个这个。

### Brainfuck
好吧，先介绍brainfuck语言。Brainfuck，是一种极小化的计算机语言，它是由Urban Müller在1993年创建的。

Müller的目标是创建一种简单的、可以用最小的编译器来实现的、符合图灵完全思想的编程语言。这种语言由八种运算符构成，为Amiga机器编写的编译器只有240个字节大小。

就象它的名字所暗示的，brainfuck程序很难读懂。尽管如此，brainfuck图灵机一样可以完成任何计算任务。虽然brainfuck的计算方式如此与众不同，但它确实能够正确运行。

这种语言基于一个简单的机器模型，除了指令，这个机器还包括：一个以字节为单位、被初始化为零的数组、一个指向该数组的指针（初始时指向数组的第一个字节）、以及用于输入输出的两个字节流。

下面是这八种状态的描述，其中每个状态由一个字符标识：

|字符|含义|
|:--:|:--:|
| >	|指针加一|
| <	|指针减一|
| +	|指针指向的字节的值加一|
| -	|指针指向的字节的值减一|
| .	|输出指针指向的单元内容（ASCII码）|
| ,	|输入内容到指针指向的单元（ASCII码）|
| [	|如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处|
| ]	|如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处|

Helloworld:
```brainfuck
++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
```

### 第 0 条军规
首先请看好本文的游戏设定：
1.不能使用任何英文字母
2.不能使用任何数字
3.不能使用` ? , : , @ , # , % , & , ^ , * , - , = `等符号
好吧，那我们能使用什么呢？

在BF语言中，用到了八种状态描述符。而在Javascript里，我们也可以用到下列八种字符：
```js
[ ] ( ) { } + !
```
可是不能降低自身的逼格啊，所以本文以下将只使用到下列六种符号：
```js
[ ] ( ) + !
```
友情提示：八种字符可以实现同样的功能，并且长度至少减少一半。

### Ramp Up
热个身先，熟悉一下上述六种符号在Javascript中常见的用法：

|字符|含义|
|:--:|:--:|
| [ ] | 简单的Array嘛，埋着许多坑 |
| ( ) | 主要用来提升逼格，不对，是优先级，组织语句快 |
| + | 即是运算符，也是字符链接，关键是还蕴涵了隐式类型转换，坑比较多 |
| ! | 这个没啥说的，基本上就是用来取反的 |

看了上面这些你会感到困惑，尼玛用这几个也能写个hello world? 可是万万没想到啊，居然真的能，更能写出猥琐的弹窗流。

以下给出Javascript的第一公设，并在此基础上推导出两个定理来构建整个大厦。
第一公设：
```
Array   =>  []
Number  =>  +[]
String  =>  []+[]
Boolean =>  ![]
```
公理1：
```
false: ![]
true: !![]
undefined: [][[]]
NaN: +[![]]
```
公理2：
```
0: +[]
1: +!+[] or +!![]
2: !+[]+!+[] or !![]+!![]
'0': +[]+[]
'10': [+!+[]]+[+[]]
```
不要问我为什么，说了我也不会告诉你，哼！

### 大道至简的数字
根据公理2，我们可以简单的表达任意正整数：
```
0: +[]
1: +!+[]
n: ∑(!+[]),i=1,2,..,n
```
如果想要表达负数，只需要添加`-`符号啦。不过目前我们不需要引入减号来扩充字符集。

如果想把数字转成字符串，即String()，在js中，一般为了偷懒，习惯于`+''`，也就是`+`的隐式类型转换，所以在最后加上一个方括号，如下：
```
'n': ( ∑(!+[]) )+[],i=1,2,..,n
```
现在我们拥有了数字了，可是据我所知，目前仅靠数字能运行的程序貌似只有二进制文件了，可是我连汇编都不知道，intel cpu上的x86指令集也不了解，所以，还是乖乖用字母手写code吧。

### 26个字母的艰难之旅
这段是本篇文章最艰难的部分，为啥这样说呢，因为为了凑齐26颗字母可谓是绞尽脑汁绕来绕去。

首先来看第一个问题：用一堆方括号加号感叹号可以凑出字母？
答案是：Yes!
How to? 思路才是王道。

我们知道，Javascript中主要的数据类型有5种，`Undefined, Null ,Boolean, Number, String, Object`。
我们从布尔值入手，`1`是数字，取反后则变成布尔类型的`false`，同理`!0`则是`true`，注意，这里返回的是类型，但我们同样可以通过`+[]`将其转换为字符串。
可以看到公理1告诉了我们如何返回这几种类型：
```
false: ![]
true: !![]
undefined: [][[]]
NaN: +[![]]
```
在js中，字符串是可以索引的，也就是说，我们可以从上面得到的字符串中提取想要的字母咯，看到这里是不是有点柳暗花明了，没错，这之后所有的字母我们都是从js内置的类型字符串中提取。

比如说字母`f`:
```
false => 'false' => 'false'[0] => 'f'
![] => ![]+[] => (![]+[])[+[]] => 'f'
```
现在我们将公理1中的字母列出如下：
```
'a': (![]+[])[+!+[]]
'd': ([][[]]+[])[+!+[]+!+[]]
'e': (!![]+[])[!+[]+!+[]+!+[]]
'f': (![]+[])[+[]]
'i': ([][[]]+[])[+!+[]+!+[]+!+[]+!+[]+!+[]]
'l': (![]+[])[!+[]+!+[]]
'n': ([][[]]+[])[+!+[]]
'r': (!![]+[])[+!+[]]
's': (![]+[])[!+[]+!+[]+!+[]]
't': (!![]+[])[+[]]
'u': ([][[]]+[])[+[]]
'N': (+[![]]+[])[+[]]
```
呃，只有12个，总感觉字母不够用啊。。

### Javascript 的 BF 化之路


### Reference
[0]. [Brainfuck - 维基百科](http://zh.wikipedia.org/wiki/Brainfuck)
[1]. [前端XSS高阶玩法](http://www.alloyteam.com/2014/11/qian-duan-xss-gao-jie-wan-fa/)
[2]. [JSFuck - Write any JavaScript with 6 Characters: \[\]()!+](http://www.jsfuck.com/)
[]. [JS数据类型](http://new-fighter.iteye.com/blog/1758707)
